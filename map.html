<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Buscar Hogar – Mapa</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />

    <style>
      :root{
        --bg:#ffffff;
        --text:#111;
        --muted:#6b7280;
        --terra:#a3472f;
        --btn:#1a73e8;
        --btnText:#fff;
        --border:#111;
        --softBorder:#e6e7eb;

        --sunbar-inner-h: 52px;
        --sunbar-outer-pad: 14px;
        --sunbar-gap: 12px;
      }

      html, body {
        height: 100%;
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      .topbar{
        height:56px;
        background:var(--terra);
        color:#fff;
        display:flex;
        align-items:center;
        padding:0 16px;
        box-sizing:border-box;
      }

      .topbarInner{
        width: min(1120px, 100%);
        margin: 0 auto;
        display:flex;
        align-items:center;
        gap: 12px;
      }

      .brand{
        display:flex;
        align-items:center;
        gap: 10px;
        text-decoration:none;
        color:#fff;
        font-weight:800;
        letter-spacing:-0.2px;
        flex: 0 0 auto;
      }

      .logoMark{
        width: 34px;
        height: 28px;
        border-radius: 6px;
        background: rgba(255,255,255,0.18);
        border: 1px solid rgba(255,255,255,0.25);
        display:grid;
        place-items:center;
        overflow:hidden;
      }

      .logoMark span{
        font-size: 12px;
        font-weight: 900;
        letter-spacing: -0.2px;
      }

      .miniSearch{
        display:flex;
        align-items:center;
        gap:10px;
        border: 1px solid rgba(255,255,255,0.30);
        background: rgba(255,255,255,0.10);
        border-radius: 999px;
        padding: 6px 10px;
        min-width: 280px;
        max-width: 460px;
        margin-left: 34px;
        flex: 1 1 auto;
      }

      .miniSearch input{
        border:0;
        outline:0;
        background: transparent;
        color: #fff;
        font-size: 13.5px;
        width: 100%;
      }

      .miniSearch input::placeholder{
        color: rgba(255,255,255,0.80);
      }

      .miniSearch button{
        border:0;
        background: transparent;
        color: #fff;
        cursor: pointer;
        padding: 0 2px;
        display:grid;
        place-items:center;
      }

      .miniIcon{
        width: 22px;
        height: 22px;
        display:block;
      }

      .rightGroup{
        margin-left: auto;
        display:flex;
        align-items:center;
        gap: 10px;
        flex: 0 0 auto;
      }

      .rightGroup a{
        color: #fff;
        text-decoration:none;
        font-size:14px;
        font-weight:650;
        padding: 8px 10px;
        border-radius: 999px;
        white-space: nowrap;
      }

      .rightGroup a:hover{
        background: rgba(255,255,255,0.14);
      }

      .page{
        height: calc(100% - 56px);
        padding: 14px 16px 16px;
        box-sizing: border-box;
      }

      .mapShell{
        width: min(1120px, 100%);
        margin: 0 auto;
        height: 100%;
        box-sizing: border-box;
        position: relative;
      }

      #map{
        height: 100%;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid #f0f1f3;
      }

      #status{
        position: absolute;
        left: 50%;
        top: 72px;
        transform: translateX(-50%);
        background: rgba(255,255,255,0.92);
        border: 1px solid rgba(0,0,0,0.10);
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 13px;
        color: #111;
        z-index: 500;
        max-width: min(980px, calc(100% - 28px));
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        pointer-events: none;
      }

      .dot {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: #ffb100;
        border: 3px solid #ffffff;
        box-shadow: 0 1px 4px rgba(0,0,0,0.25);
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      }
      .dot:hover { transform: scale(1.15); }
      .dot.active {
        background: #1a73e8;
        border-color: #0b3d91;
        transform: scale(1.15);
      }

      .card {
        position: fixed;
        left: 50%;
        bottom: 18px;
        width: min(720px, calc(100% - 28px));
        background: #fff;
        border: 1px solid rgba(0,0,0,0.14);
        border-radius: 12px;
        box-shadow: 0 14px 38px rgba(0,0,0,0.18);
        z-index: 9999;
        overflow: hidden;

        opacity: 0;
        pointer-events: none;
        transform: translateX(-50%) translateY(10px);
        transition: opacity 160ms ease, transform 160ms ease;
      }

      .card.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }

      .cardGrid {
        display: grid;
        grid-template-columns: 35% 65%;
        height: 143px;
      }

      .mediaSide {
        position: relative;
        background: #f1f2f4;
        overflow: hidden;
        height: 100%;
      }

      .mediaImg {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .mediaPlaceholder {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        color: #9aa1aa;
        font-size: 13px;
      }

      .badgeNew {
        position: absolute;
        top: 10px;
        left: 10px;
        background: #f7a300;
        color: #fff;
        padding: 5px 10px;
        border-radius: 9px;
        font-size: 12px;
        font-weight: 700;
        display: none;
      }

      .mediaMiniIcon {
        position: absolute;
        left: 10px;
        bottom: 10px;
        width: 30px;
        height: 30px;
        border-radius: 10px;
        background: rgba(255,255,255,0.94);
        border: 1px solid rgba(0,0,0,0.10);
        display: grid;
        place-items: center;
      }
      .mediaMiniIcon svg {
        width: 16px;
        height: 16px;
        color: rgba(0,0,0,0.75);
      }

      .textSide {
        position: relative;
        padding: 12px 14px 12px;
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
      }

      .topActions {
        position: absolute;
        right: 10px;
        top: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .heartBtn {
        width: 38px;
        height: 38px;
        border-radius: 999px;
        border: 1px solid rgba(0,0,0,0.18);
        background: #fff;
        cursor: pointer;
        display: grid;
        place-items: center;
      }
      .heartBtn svg {
        width: 18px;
        height: 18px;
        color: #1a73e8;
      }

      .closeBtn {
        width: 44px;
        height: 44px;
        border-radius: 10px;
        border: 0;
        background: #1a73e8;
        cursor: pointer;
        display: grid;
        place-items: center;
      }
      .closeBtn svg {
        width: 20px;
        height: 20px;
        color: #fff;
      }

      .addrTop {
        color: #1a73e8;
        text-decoration: none;
        font-size: 18px;
        line-height: 1.08;
        font-weight: 650;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        padding-right: 112px;
        max-height: calc(1.08em * 2);
      }
      .addrTop:hover { text-decoration: underline; }

      .addrBottom {
        margin-top: 5px;
        font-size: 16px;
        color: #111;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .price {
        margin-top: 10px;
        font-size: 16px;
        font-weight: 900;
        color: #111;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .facts {
        margin-top: 8px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        color: rgba(0,0,0,0.85);
        font-size: 13px;
        overflow: hidden;
      }

      .fact {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        white-space: nowrap;
      }

      .fact svg {
        width: 18px;
        height: 18px;
        color: rgba(0,0,0,0.75);
      }

      .agency {
        margin-top: auto;
        padding-top: 10px;
        font-size: 14px;
        font-weight: 400;
        color: #1a73e8;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      @media (max-width: 720px) {
        .miniSearch{ display:none; }
        .page{ padding: 10px 10px 10px; }
        .mapShell{ width: 100%; }

        #status{
          top: 66px;
          max-width: calc(100% - 20px);
        }

        .card { width: calc(100% - 22px); bottom: 14px; }

        .cardGrid {
          grid-template-columns: 1fr;
          height: 320px;
        }

        .mediaSide { height: 210px; }
        .textSide { height: calc(320px - 210px); }

        .addrTop { padding-right: 0; font-size: 18px; }
        .addrBottom { font-size: 16px; }
        .price { font-size: 16px; }
        .facts { font-size: 13px; }
        .agency { font-size: 14px; }
        .topActions { right: 10px; top: 10px; }
      }

      .leaflet-control-zoom a {
        width: 34px;
        height: 34px;
        line-height: 34px;
        border-radius: 10px;
      }
      .leaflet-bar a, .leaflet-bar a:hover {
        border-bottom: 1px solid rgba(0,0,0,0.08);
      }

      .quickCol {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
.quickRow{
        display:flex;
        flex-direction: row;
        gap: 10px;
      }

      .qBtn {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid rgba(0,0,0,0.14);
        background: rgba(255,255,255,0.96);
        cursor: pointer;
        display: grid;
        place-items: center;
        box-shadow: 0 10px 24px rgba(0,0,0,0.12);
        user-select: none;
      }
      .qBtn:hover { background: #fff; }
      .qBtn svg { width: 20px; height: 20px; color: rgba(0,0,0,0.80); }

      .qBtn.active {
        border-color: rgba(26,115,232,0.55);
        box-shadow: 0 12px 28px rgba(26,115,232,0.16);
      }

      .qBtn.disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }

  .qBtnSmall{
        width: 40px;
        height: 40px;
        border-radius: 11px;
        border: 1px solid rgba(0,0,0,0.14);
        background: rgba(255,255,255,0.96);
        cursor: pointer;
        display: grid;
        place-items:center;
        box-shadow: 0 10px 22px rgba(0,0,0,0.10);
        user-select: none;
      }
      .qBtnSmall:hover{ background:#fff; }
      .qBtnSmall svg{ width: 18px; height: 18px; color: rgba(0,0,0,0.78); }

      .qBtnSmall.active{
        border-color: rgba(26,115,232,0.55);
        box-shadow: 0 12px 26px rgba(26,115,232,0.16);
      }

      .qBtnSmall.disabled{
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }

.areaHint{
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        z-index: 760;
        display: none;
        pointer-events: none;
        max-width: calc(100% - 28px);
      }
      .areaHintInner{
        height: 44px;
        padding: 10px 14px;
        border-radius: 14px;
        background: rgba(255,255,255,0.78);
        border: 1px solid rgba(0,0,0,0.10);
        backdrop-filter: blur(6px);
        box-sizing: border-box;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      .areaHintDot{
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(26,115,232,0.85);
        flex: 0 0 auto;
      }
      .areaHintText{
        font-size: 13px;
        color: rgba(0,0,0,0.78);
        white-space: nowrap;
        text-align: center;
      }

      .areaDel{
        width: 22px;
        height: 22px;
        border-radius: 8px;
        background: rgba(255,255,255,0.92);
        border: 1px solid rgba(0,0,0,0.18);
        box-shadow: 0 10px 22px rgba(0,0,0,0.14);
        display: grid;
        place-items: center;
        user-select: none;
        cursor: pointer;
      }
      .areaDel span{
        font-size: 14px;
        line-height: 1;
        color: rgba(0,0,0,0.62);
        transform: translateY(-0.5px);
      }

    @media (max-width: 720px) {
        .areaHint{
          left: 50%;
          bottom: 10px;
          transform: translateX(-50%);
          max-width: calc(100% - 20px);
        }
        .areaHintInner{
          height: 42px;
        }
        .qBtnSmall{
          width: 38px;
          height: 38px;
        }
      }

      .sunOverlay {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 650;
        width: min(72vmin, 760px);
        height: min(72vmin, 760px);
        display: none;
        pointer-events: none;
      }

      .sunOverlay svg{
        width: 100%;
        height: 100%;
        display: block;
      }

      .sunOverlayLabel{
        position: absolute;
        left: 50%;
        top: -38px;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.62);
        color: rgba(255,255,255,0.92);
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        line-height: 1;
        white-space: nowrap;
      }

      @media (max-width: 720px) {
        .sunOverlay{
          width: min(78vmin, 520px);
          height: min(78vmin, 520px);
        }
        .sunOverlayLabel{
          top: -34px;
          font-size: 12.5px;
        }
      }

      .sunTimebar {
        position: absolute;
        left: 14px;
        right: 14px;
        bottom: 14px;
        z-index: 700;
        display: none;
        pointer-events: auto;
      }

      .sunTimebarInner{
        position: relative;
        height: var(--sunbar-inner-h);
        padding: 8px 12px;
        border-radius: 14px;
        background: rgba(255,255,255,0.78);
        border: 1px solid rgba(0,0,0,0.10);
        backdrop-filter: blur(6px);
        box-sizing: border-box;
        display: grid;
        grid-template-rows: 14px 1fr;
        gap: 8px;
      }

      .sunHoursRow{
        display: grid;
        grid-template-columns: repeat(24, 1fr);
        gap: 0;
        font-size: 10.5px;
        color: rgba(0,0,0,0.58);
        user-select: none;
        line-height: 14px;
      }

      .sunHoursRow span{
        text-align: center;
        transform: translateY(-1px);
      }

      .sunTrack {
        position: relative;
        height: 14px;
        border-radius: 999px;
        background:
          linear-gradient(to right,
            rgba(255,176,0,0.0) 0%,
            rgba(255,176,0,0.0) var(--sr, 0%),
            rgba(255,176,0,0.16) var(--sr, 0%),
            rgba(255,176,0,0.16) var(--ss, 0%),
            rgba(255,176,0,0.0) var(--ss, 0%),
            rgba(255,176,0,0.0) 100%
          );
        border: 1px solid rgba(0,0,0,0.10);
        overflow: hidden;
      }

      .sunTrack:before{
        content:"";
        position:absolute;
        inset: 0;
        background: linear-gradient(to right, rgba(0,0,0,0.06), rgba(0,0,0,0.03));
        opacity: 0.28;
        pointer-events:none;
      }

      .sunRange {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        margin: 0;
        appearance: none;
        background: transparent;
        outline: none;
      }

      .sunRange::-webkit-slider-thumb{
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: rgba(255,176,0,0.96);
        border: 3px solid rgba(255,255,255,0.96);
        box-shadow: 0 8px 18px rgba(0,0,0,0.16);
        cursor: pointer;
      }
      .sunRange::-moz-range-thumb{
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: rgba(255,176,0,0.96);
        border: 3px solid rgba(255,255,255,0.96);
        box-shadow: 0 8px 18px rgba(0,0,0,0.16);
        cursor: pointer;
      }

      .sunDateDock{
        position: absolute;
        right: 14px;
        bottom: calc(var(--sunbar-outer-pad) + var(--sunbar-inner-h) + var(--sunbar-gap));
        z-index: 720;
        display: none;
        pointer-events: auto;
      }

      .sunDateDockInner{
        display:flex;
        align-items:center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(255,255,255,0.78);
        border: 1px solid rgba(0,0,0,0.10);
        backdrop-filter: blur(6px);
      }

      .sunDateDock input[type="date"]{
        font-size: 12.5px;
        padding: 7px 10px;
        border-radius: 12px;
        border: 1px solid rgba(0,0,0,0.12);
        background: rgba(255,255,255,0.92);
        outline: none;
      }

      .sunDateDock button{
        border: 0;
        background: rgba(0,0,0,0.70);
        color: rgba(255,255,255,0.92);
        padding: 8px 12px;
        border-radius: 12px;
        cursor: pointer;
        font-size: 12.5px;
        font-weight: 650;
      }

      .sunDateDock button:hover{
        background: rgba(0,0,0,0.78);
      }

      @media (max-width: 720px) {
        :root{
          --sunbar-inner-h: 50px;
          --sunbar-outer-pad: 10px;
          --sunbar-gap: 10px;
        }

        .sunTimebar{
          left: 10px;
          right: 10px;
          bottom: 10px;
        }
        .sunDateDock{
          right: 10px;
        }
        .sunHoursRow{
          font-size: 10px;
        }
      }
    </style>
  </head>

  <body>
    <header class="topbar">
      <div class="topbarInner">
        <a class="brand" href="./">
          <div class="logoMark" aria-label="Logo">
            <span>BH</span>
          </div>
        </a>

        <form class="miniSearch" id="miniSearchForm" autocomplete="off" aria-label="Búsqueda rápida">
          <input id="miniQ" placeholder="Buscar..." aria-label="Buscar rápido" />
          <button type="submit" title="Buscar" aria-label="Buscar">
            <svg class="miniIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="7"></circle>
              <path d="M21 21l-4.3-4.3"></path>
            </svg>
          </button>
        </form>

        <div class="rightGroup" aria-label="Acciones">
          <a href="#" id="navFavoritos">Favoritos</a>
          <a href="#" id="navLogin">Iniciar sesión</a>
        </div>
      </div>
    </header>

    <div class="page">
      <div class="mapShell">
        <div id="map"></div>

        <div id="sunOverlay" class="sunOverlay" aria-hidden="true">
          <div id="sunOverlayLabel" class="sunOverlayLabel">—</div>
          <svg id="sunPolarOverlay" aria-label="Diagrama solar"></svg>
        </div>

        <div id="sunDateDock" class="sunDateDock" aria-hidden="true">
          <div class="sunDateDockInner">
            <input type="date" id="sunDate" />
            <button type="button" id="sunNowBtn">Ahora</button>
          </div>
        </div>

        <div id="sunTimebar" class="sunTimebar" aria-hidden="true">
          <div class="sunTimebarInner">
            <div class="sunHoursRow" id="sunHoursRow"></div>
            <div class="sunTrack" id="sunTrack">
              <input id="sunRange" class="sunRange" type="range" min="0" max="1439" step="10" />
            </div>
          </div>
        </div>

        <div id="areaHint" class="areaHint" aria-hidden="true">
          <div class="areaHintInner">
            <div class="areaHintDot" aria-hidden="true"></div>
            <div id="areaHintText" class="areaHintText">—</div>
          </div>
        </div>
      </div>
    </div>

    <div id="status"></div>

    <div id="card" class="card">
      <div class="cardGrid">
        <div class="mediaSide">
          <span id="badgeNew" class="badgeNew">Nuevo</span>
          <img id="mediaImg" class="mediaImg" alt="" style="display:none;" />
          <div id="mediaPlaceholder" class="mediaPlaceholder">Foto</div>

          <div class="mediaMiniIcon" title="Fotos">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h3l2-2h4l2 2h3a2 2 0 0 1 2 2z"/>
              <path d="M12 17a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"/>
            </svg>
          </div>
        </div>

        <div class="textSide">
          <div class="topActions">
            <button class="heartBtn" id="heartBtn" type="button" aria-label="Guardar">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20.8 4.6a5.5 5.5 0 0 0-7.8 0L12 5.6l-1-1a5.5 5.5 0 0 0-7.8 7.8l1 1L12 21l7.8-7.6 1-1a5.5 5.5 0 0 0 0-7.8z"/>
              </svg>
            </button>

            <button class="closeBtn" id="cardClose" type="button" aria-label="Cerrar">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18"/><path d="M6 6l12 12"/>
              </svg>
            </button>
          </div>

          <a id="cardAddrTop" class="addrTop" href="#">Dirección</a>
          <div id="cardAddrBottom" class="addrBottom">—</div>

          <div id="cardPrice" class="price">—</div>
          <div id="cardFacts" class="facts"></div>

          <div id="cardAgency" class="agency">—</div>
        </div>
      </div>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

    <script>
      const SUPABASE_URL = "https://dpusnylssfjnksbieimj.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_tSSgJcWWRfEe2uob7SFYgw_AqcBL7KK";

      const DEFAULT_CENTER = [37.9838, -1.1280];
      const DEFAULT_ZOOM = 13;

      const statusEl = document.getElementById("status");
      const miniSearchForm = document.getElementById("miniSearchForm");
      const miniQ = document.getElementById("miniQ");

      const cardEl = document.getElementById("card");
      const cardCloseBtn = document.getElementById("cardClose");
      const heartBtn = document.getElementById("heartBtn");

      const badgeNewEl = document.getElementById("badgeNew");
      const mediaImgEl = document.getElementById("mediaImg");
      const mediaPlaceholderEl = document.getElementById("mediaPlaceholder");

      const cardAddrTopEl = document.getElementById("cardAddrTop");
      const cardAddrBottomEl = document.getElementById("cardAddrBottom");
      const cardPriceEl = document.getElementById("cardPrice");
      const cardFactsEl = document.getElementById("cardFacts");
      const cardAgencyEl = document.getElementById("cardAgency");

      const sunOverlayEl = document.getElementById("sunOverlay");
      const sunOverlayLabelEl = document.getElementById("sunOverlayLabel");
      const sunPolarOverlaySvg = document.getElementById("sunPolarOverlay");

      const sunTimebarEl = document.getElementById("sunTimebar");
      const sunDateDockEl = document.getElementById("sunDateDock");
      const sunHoursRowEl = document.getElementById("sunHoursRow");
      const sunTrackEl = document.getElementById("sunTrack");
      const sunRangeEl = document.getElementById("sunRange");
      const sunDateEl = document.getElementById("sunDate");
      const sunNowBtn = document.getElementById("sunNowBtn");

      const areaHintEl = document.getElementById("areaHint");
      const areaHintTextEl = document.getElementById("areaHintText");

      function setStatus(msg) { statusEl.textContent = msg || ""; }

      function euro(n) {
        try {
          return new Intl.NumberFormat("es-ES", { style: "currency", currency: "EUR", maximumFractionDigits: 0 }).format(n);
        } catch {
          return `${n} EUR`;
        }
      }

      function openCard() { cardEl.classList.add("visible"); }
      function closeCard() { cardEl.classList.remove("visible"); }
      cardCloseBtn.addEventListener("click", closeCard);

      let heartOn = false;
      heartBtn.addEventListener("click", () => {
        heartOn = !heartOn;
        heartBtn.style.borderColor = heartOn ? "rgba(26,115,232,0.55)" : "rgba(0,0,0,0.18)";
        heartBtn.style.boxShadow = heartOn ? "0 6px 18px rgba(26,115,232,0.18)" : "none";
      });

      function setPhoto(url) {
        if (!url) {
          mediaImgEl.style.display = "none";
          mediaImgEl.removeAttribute("src");
          mediaPlaceholderEl.style.display = "grid";
          return;
        }

        mediaImgEl.src = url;
        mediaImgEl.style.display = "block";
        mediaPlaceholderEl.style.display = "none";

        mediaImgEl.onerror = () => {
          mediaImgEl.style.display = "none";
          mediaImgEl.removeAttribute("src");
          mediaPlaceholderEl.style.display = "grid";
        };
      }

      function isRecent(listedAtIso, days = 14) {
        if (!listedAtIso) return false;
        const d = new Date(listedAtIso);
        if (isNaN(d.getTime())) return false;
        const diff = Date.now() - d.getTime();
        return diff >= 0 && diff <= days * 24 * 60 * 60 * 1000;
      }

      function iconArea() {
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M4 10h16"/><path d="M10 10v10"/></svg>';
      }
      function iconType() {
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 11l9-8 9 8"/><path d="M5 10v10h14V10"/></svg>';
      }

      function joinNonEmpty(parts, sep) {
        return parts.map(v => (v == null ? "" : String(v).trim()))
          .filter(v => v.length > 0)
          .join(sep);
      }

      function buildAddressTop(p) {
        const base = joinNonEmpty([p.street_name, p.street_number], " ");
        const extras = joinNonEmpty([p.building, p.staircase, p.floor, p.door], ", ");
        if (base && extras) return base + ", " + extras;
        return base || extras || "Dirección";
      }

      function buildAddressBottom(p) {
        const line = joinNonEmpty([p.postcode, p.city], " ");
        return line || "—";
      }

      function openCardForPoint(p) {
        cardAddrTopEl.textContent = buildAddressTop(p);
        cardAddrBottomEl.textContent = buildAddressBottom(p);

        cardAddrTopEl.href = `listing.html?id=${encodeURIComponent(p.listing_id)}`;

        cardPriceEl.textContent = (p.price_eur != null) ? euro(p.price_eur) : "—";

        setPhoto(p.main_photo_url || null);

        badgeNewEl.style.display = isRecent(p.listed_at, 14) ? "inline-flex" : "none";

        const m2 = (p.useful_area_m2 != null) ? `${p.useful_area_m2} m²` : "— m²";
        const type = p.property_type ? String(p.property_type) : "—";

        cardFactsEl.innerHTML = `
          <div class="fact">${iconArea()}<span>${m2} m² útiles</span></div>
          <div class="fact">${iconType()}<span>${type}</span></div>
        `;

        cardAgencyEl.textContent = p.agency_name || "—";
        openCard();
      }

      function toInt(v) {
        if (v == null || v === "") return null;
        const n = parseInt(String(v), 10);
        return Number.isFinite(n) ? n : null;
      }

      function toText(v) {
        if (v == null) return null;
        const s = String(v).trim();
        return s.length ? s : null;
      }

      function toTextArray(csv) {
        if (!csv) return null;
        const arr = String(csv).split(",").map(s => s.trim()).filter(Boolean);
        return arr.length ? arr : null;
      }

      function getParams() {
        const u = new URL(window.location.href);

        let mode = (u.searchParams.get("mode") || "").trim().toLowerCase();
        if (!mode) mode = "buy";

        const allowed = ["buy","rent","room","new_build","all"];
        if (!allowed.includes(mode)) mode = "buy";

        return {
          city: (u.searchParams.get("city") || "").trim(),
          mode,

          priceMin: toInt(u.searchParams.get("price_min")),
          priceMax: toInt(u.searchParams.get("price_max")),

          listedSinceDays: toInt(u.searchParams.get("since_days")),
          availability: toText(u.searchParams.get("availability")),

          usefulMin: toInt(u.searchParams.get("useful_min")),
          usefulMax: toInt(u.searchParams.get("useful_max")),

          builtMin: toInt(u.searchParams.get("built_min")),
          builtMax: toInt(u.searchParams.get("built_max")),

          bedroomsMin: toInt(u.searchParams.get("bedrooms_min")),
          bathroomsMin: toInt(u.searchParams.get("bathrooms_min")),

          outdoorType: toText(u.searchParams.get("outdoor_type")),
          orientations: toTextArray(u.searchParams.get("orientations")),

          energyChoice: toText(u.searchParams.get("energy")),

          buildPeriods: toTextArray(u.searchParams.get("build_periods")),

          parkingTypes: toTextArray(u.searchParams.get("parking")),
          storageTypes: toTextArray(u.searchParams.get("storage")),

          accessibility: toTextArray(u.searchParams.get("accessibility"))
        };
      }

      const initialParams = getParams();

      let map = L.map("map").setView(DEFAULT_CENTER, DEFAULT_ZOOM);

      L.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap &copy; CARTO"
      }).addTo(map);

      let markersLayer = L.layerGroup().addTo(map);
      let activeMarker = null;

      function clearMarkers() {
        markersLayer.clearLayers();
        activeMarker = null;
      }

      function addPoint(p) {
        if (p.lat == null || p.lng == null) return;

        const el = document.createElement("div");
        el.className = "dot";

        const icon = L.divIcon({
          className: "",
          html: el,
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        });

        const m = L.marker([p.lat, p.lng], { icon }).addTo(markersLayer);

        m.on("click", () => {
          if (areaState.isDrawing) return;
          if (activeMarker && activeMarker._icon) {
            activeMarker._icon.querySelector(".dot")?.classList.remove("active");
          }
          activeMarker = m;
          m._icon.querySelector(".dot")?.classList.add("active");
          openCardForPoint(p);
        });
      }

      function getCurrentBounds() {
        const b = map.getBounds();
        return {
          south: b.getSouthWest().lat,
          west: b.getSouthWest().lng,
          north: b.getNorthEast().lat,
          east: b.getNorthEast().lng
        };
      }

      async function rpcSearchMapPoints(bounds, filters) {
        const body = {
          p_south: bounds.south,
          p_west: bounds.west,
          p_north: bounds.north,
          p_east: bounds.east,

          p_mode: (filters.mode && filters.mode !== "all") ? filters.mode : null,

          p_price_min: filters.priceMin,
          p_price_max: filters.priceMax,

          p_listed_since_days: filters.listedSinceDays,
          p_availability: filters.availability,

          p_useful_min: filters.usefulMin,
          p_useful_max: filters.usefulMax,

          p_built_min: filters.builtMin,
          p_built_max: filters.builtMax,

          p_bedrooms_min: filters.bedroomsMin,
          p_bathrooms_min: filters.bathroomsMin,

          p_outdoor_type: filters.outdoorType,
          p_orientations: filters.orientations,

          p_energy_choice: filters.energyChoice,

          p_build_periods: filters.buildPeriods,

          p_parking_types: filters.parkingTypes,
          p_storage_types: filters.storageTypes,

          p_accessibility: filters.accessibility
        };

        const url = `${SUPABASE_URL}/rest/v1/rpc/search_map_points_filtered`;

        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            apikey: SUPABASE_ANON_KEY,
            Authorization: `Bearer ${SUPABASE_ANON_KEY}`
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          const txt = await res.text();
          throw new Error(txt);
        }

        return await res.json();
      }

      let debounceTimer = null;

      /* =========================
         AREAS (puntos + libre)
         ========================= */

      const MAX_AREAS = 5;

      const areaState = {
        mode: null,              // "points" | "freehand" | null
        isDrawing: false,
        isFreehandActive: false,
        points: [],
        tempLine: null,
        tempFirstMarker: null,
        tempVertexMarkers: [],
        tempLivePoly: null,
        polys: [],               // { id, latlngs, poly, delMarker }
        nextId: 1,
        plusBtnEl: null,
        btnPointsEl: null,
        btnFreeEl: null,
        sunBtnEl: null,
        sunBtnSetActive: null,   // set from SunControl
        sunBtnForceOff: null,    // set from SunControl
        lastHint: ""
      };

      const areasLayer = L.layerGroup().addTo(map);

      function setAreaHintVisible(visible, text){
        areaHintEl.style.display = visible ? "block" : "none";
        areaHintEl.setAttribute("aria-hidden", visible ? "false" : "true");
        if (typeof text === "string") {
          areaHintTextEl.textContent = text;
          areaState.lastHint = text;
        }
      }

      function setMarkersVisible(visible){
        const has = map.hasLayer(markersLayer);
        if (visible && !has) markersLayer.addTo(map);
        if (!visible && has) map.removeLayer(markersLayer);
      }

      function clearTempDrawing(){
        if (areaState.tempLine) { areasLayer.removeLayer(areaState.tempLine); areaState.tempLine = null; }
        if (areaState.tempLivePoly) { areasLayer.removeLayer(areaState.tempLivePoly); areaState.tempLivePoly = null; }

        if (areaState.tempFirstMarker) {
          areasLayer.removeLayer(areaState.tempFirstMarker);
          areaState.tempFirstMarker = null;
        }

        areaState.tempVertexMarkers.forEach(m => areasLayer.removeLayer(m));
        areaState.tempVertexMarkers = [];
        areaState.points = [];
      }

      function setAreaMode(nextMode){
        if (nextMode !== "points" && nextMode !== "freehand") nextMode = null;

        if (nextMode && areaState.sunBtnForceOff) {
          areaState.sunBtnForceOff();
        }

        if (areaState.mode && areaState.mode !== nextMode) {
          cancelAreaDrawingOnly();
        }

        areaState.mode = nextMode;

        if (areaState.btnPointsEl) areaState.btnPointsEl.classList.toggle("active", nextMode === "points");
        if (areaState.btnFreeEl) areaState.btnFreeEl.classList.toggle("active", nextMode === "freehand");

        if (!nextMode) {
          setAreaHintVisible(false, "");
          areaState.isDrawing = false;
          areaState.isFreehandActive = false;
          clearTempDrawing();
          setMarkersVisible(true);
          closeCard();
        } else {
          startNewAreaDrawing();
        }

        updatePlusVisibility();
      }

      function cancelAreaDrawingOnly(){
        if (!areaState.mode) return;
        areaState.isDrawing = false;
        areaState.isFreehandActive = false;
        clearTempDrawing();
        setMarkersVisible(true);
        setAreaHintVisible(false, "");
      }

      function deactivateAreasIfNone(){
        if (areaState.polys.length === 0) {
          if (areaState.mode) {
            if (areaState.btnPointsEl) areaState.btnPointsEl.classList.remove("active");
            if (areaState.btnFreeEl) areaState.btnFreeEl.classList.remove("active");
          }
          areaState.mode = null;
          areaState.isDrawing = false;
          areaState.isFreehandActive = false;
          clearTempDrawing();
          setMarkersVisible(true);
          setAreaHintVisible(false, "");
        }
        updatePlusVisibility();
      }

      function updatePlusVisibility(){
        const can = (areaState.polys.length >= 1) && (areaState.polys.length < MAX_AREAS);
        if (areaState.plusBtnEl) {
          areaState.plusBtnEl.style.display = can ? "grid" : "none";
        }
      }

      function latlngsToSimple(latlngs){
        return latlngs.map(ll => ({ lat: ll.lat, lng: ll.lng }));
      }

      function pointInPoly(lat, lng, poly){
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].lng, yi = poly[i].lat;
          const xj = poly[j].lng, yj = poly[j].lat;

          const intersect = ((yi > lat) !== (yj > lat)) &&
            (lng < (xj - xi) * (lat - yi) / ((yj - yi) || 1e-12) + xi);

          if (intersect) inside = !inside;
        }
        return inside;
      }

      function isInsideAnyArea(p){
        if (!areaState.polys.length) return true;
        if (p.lat == null || p.lng == null) return false;
        const lat = p.lat, lng = p.lng;
        for (const a of areaState.polys) {
          if (pointInPoly(lat, lng, a.latlngs)) return true;
        }
        return false;
      }

      function northwestVertex(latlngs){
        let best = null;
        for (const ll of latlngs) {
          if (!best) { best = ll; continue; }
          if (ll.lat > best.lat) best = ll;
          else if (ll.lat === best.lat && ll.lng < best.lng) best = ll;
        }
        return best || latlngs[0];
      }

      function makeDelMarker(latlng, areaId){
        const el = document.createElement("div");
        el.className = "areaDel";
        const s = document.createElement("span");
        s.textContent = "×";
        el.appendChild(s);

        const icon = L.divIcon({
          className: "",
          html: el,
          iconSize: [22,22],
          iconAnchor: [11,11]
        });

        const m = L.marker(latlng, { icon, interactive: true, keyboard: false });

        m.on("click", (e) => {
          L.DomEvent.stopPropagation(e);
          removeAreaById(areaId);
        });

        return m;
      }

      function removeAreaById(id){
        const idx = areaState.polys.findIndex(x => x.id === id);
        if (idx < 0) return;
        const a = areaState.polys[idx];

        if (a.poly) areasLayer.removeLayer(a.poly);
        if (a.delMarker) areasLayer.removeLayer(a.delMarker);

        areaState.polys.splice(idx, 1);

        if (areaState.polys.length === 0) {
          closeCard();
          deactivateAreasIfNone();
          scheduleReload();
          return;
        }

        updatePlusVisibility();
        scheduleReload();
      }

      function addAreaPolygon(latlngs){
        if (!latlngs || latlngs.length < 3) return false;
        if (areaState.polys.length >= MAX_AREAS) return false;

        const id = areaState.nextId++;
        const poly = L.polygon(latlngs, {
          color: "rgba(26,115,232,0.80)",
          weight: 3,
          opacity: 1,
          fillColor: "rgba(26,115,232,0.20)",
          fillOpacity: 0.18
        }).addTo(areasLayer);

        const nw = northwestVertex(latlngs);
        const delMarker = makeDelMarker(nw, id).addTo(areasLayer);

        areaState.polys.push({
          id,
          latlngs: latlngsToSimple(latlngs),
          poly,
          delMarker
        });

        updatePlusVisibility();
        return true;
      }

      function startNewAreaDrawing(){
        if (!areaState.mode) return;

        if (areaState.polys.length >= MAX_AREAS) {
          updatePlusVisibility();
          return;
        }

        closeCard();
        clearTempDrawing();
        areaState.isDrawing = true;
        setMarkersVisible(false);

        if (areaState.mode === "points") {
          setAreaHintVisible(true, "Haz clic punto a punto para dibujar el área. Cierra en el primer punto.");
          areaState.points = [];
          areaState.tempLine = L.polyline([], {
            color: "rgba(26,115,232,0.88)",
            weight: 3,
            opacity: 1
          }).addTo(areasLayer);
        }

        if (areaState.mode === "freehand") {
          setAreaHintVisible(true, "Mantén pulsado y dibuja el área. Suelta para terminar.");
          areaState.points = [];
          areaState.isFreehandActive = false;
        }
      }

      function finishDrawingPoints(){
        const pts = areaState.points.slice();
        if (pts.length < 3) {
          clearTempDrawing();
          areaState.isDrawing = false;
          setMarkersVisible(true);
          setAreaHintVisible(false, "");
          scheduleReload();
          return;
        }

        const ok = addAreaPolygon(pts);
        clearTempDrawing();
        areaState.isDrawing = false;
        setMarkersVisible(true);
        setAreaHintVisible(false, "");

        if (ok) {
          scheduleReload();
        } else {
          scheduleReload();
        }
      }

      function addPointVertex(latlng){
        areaState.points.push(latlng);

        if (areaState.tempLine) {
          areaState.tempLine.addLatLng(latlng);
        }

        const isFirst = areaState.points.length === 1;

        const circle = L.circleMarker(latlng, {
          radius: isFirst ? 7 : 6,
          color: "rgba(255,255,255,0.95)",
          weight: 3,
          fillColor: "rgba(26,115,232,0.90)",
          fillOpacity: 1
        }).addTo(areasLayer);

        if (isFirst) {
          areaState.tempFirstMarker = circle;
          circle.on("click", (e) => {
            L.DomEvent.stopPropagation(e);
            if (!areaState.isDrawing || areaState.mode !== "points") return;
            finishDrawingPoints();
          });
        } else {
          areaState.tempVertexMarkers.push(circle);
        }
      }

      function maybeCloseFirst(latlng){
        if (!areaState.tempFirstMarker) return false;
        const first = areaState.points[0];
        if (!first) return false;
        const d = map.distance(first, latlng);
        return d <= 12;
      }

      function simplifyRDP(points, epsilonPx){
        if (!points || points.length < 3) return points || [];
        const sqEps = epsilonPx * epsilonPx;

        function sqDist(a, b){
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          return dx*dx + dy*dy;
        }

        function sqSegDist(p, a, b){
          let x = a.x, y = a.y;
          let dx = b.x - x;
          let dy = b.y - y;

          if (dx !== 0 || dy !== 0) {
            const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx*dx + dy*dy);
            if (t > 1) { x = b.x; y = b.y; }
            else if (t > 0) { x += dx * t; y += dy * t; }
          }

          dx = p.x - x;
          dy = p.y - y;
          return dx*dx + dy*dy;
        }

        function rdp(pts, first, last, out){
          let maxSqDist = sqEps;
          let index = -1;

          for (let i = first + 1; i < last; i++) {
            const sqD = sqSegDist(pts[i], pts[first], pts[last]);
            if (sqD > maxSqDist) {
              index = i;
              maxSqDist = sqD;
            }
          }

          if (index !== -1) {
            if (index - first > 1) rdp(pts, first, index, out);
            out.push(pts[index]);
            if (last - index > 1) rdp(pts, index, last, out);
          }
        }

        const out = [points[0]];
        rdp(points, 0, points.length - 1, out);
        out.push(points[points.length - 1]);
        return out;
      }

      function latlngsFromFreehand(rawLatLngs){
        if (!rawLatLngs || rawLatLngs.length < 3) return [];
        const zoom = map.getZoom();
        const proj = rawLatLngs.map(ll => {
          const p = map.project(ll, zoom);
          return { x: p.x, y: p.y, ll };
        });

        const simplified = simplifyRDP(proj, 3.0);
        const out = simplified.map(p => p.ll);

        if (out.length >= 3) {
          const first = out[0];
          const last = out[out.length - 1];
          const d = map.distance(first, last);
          if (d > 5) out.push(first);
        }

        const uniq = [];
        for (const ll of out) {
          const prev = uniq[uniq.length - 1];
          if (!prev) { uniq.push(ll); continue; }
          const dd = map.distance(prev, ll);
          if (dd >= 1) uniq.push(ll);
        }
        return uniq.length >= 3 ? uniq : [];
      }

      let freehandMoveHandler = null;
      let freehandUpHandler = null;
      let freehandLastSample = null;

      function startFreehand(e){
        if (!areaState.isDrawing || areaState.mode !== "freehand") return;
        if (areaState.isFreehandActive) return;

        areaState.isFreehandActive = true;
        areaState.points = [];
        freehandLastSample = null;

        map.dragging.disable();

        const startLL = e.latlng;
        if (startLL) {
          areaState.points.push(startLL);
          freehandLastSample = { ll: startLL, t: Date.now() };
        }

        if (areaState.tempLine) { areasLayer.removeLayer(areaState.tempLine); areaState.tempLine = null; }
        if (areaState.tempLivePoly) { areasLayer.removeLayer(areaState.tempLivePoly); areaState.tempLivePoly = null; }

        areaState.tempLine = L.polyline([startLL], {
          color: "rgba(26,115,232,0.88)",
          weight: 3,
          opacity: 1
        }).addTo(areasLayer);

        freehandMoveHandler = (ev) => {
          if (!areaState.isFreehandActive) return;
          const ll = ev.latlng;
          if (!ll) return;

          const now = Date.now();
          const prev = freehandLastSample?.ll;

          let ok = true;
          if (freehandLastSample) {
            const dt = now - freehandLastSample.t;
            const dist = prev ? map.distance(prev, ll) : 999;
            ok = (dt >= 18) && (dist >= 2.0);
          }

          if (!ok) return;

          areaState.points.push(ll);
          freehandLastSample = { ll, t: now };
          if (areaState.tempLine) areaState.tempLine.addLatLng(ll);
        };

        freehandUpHandler = () => {
          finishFreehand();
        };

        map.on("mousemove", freehandMoveHandler);
        map.on("mouseup", freehandUpHandler);

        map.on("touchmove", freehandMoveHandler);
        map.on("touchend", freehandUpHandler);
        map.on("touchcancel", freehandUpHandler);
      }

      function finishFreehand(){
        if (!areaState.isDrawing || areaState.mode !== "freehand") return;

        map.off("mousemove", freehandMoveHandler);
        map.off("mouseup", freehandUpHandler);
        map.off("touchmove", freehandMoveHandler);
        map.off("touchend", freehandUpHandler);
        map.off("touchcancel", freehandUpHandler);

        freehandMoveHandler = null;
        freehandUpHandler = null;

        if (areaState.tempLine) { areasLayer.removeLayer(areaState.tempLine); areaState.tempLine = null; }

        map.dragging.enable();

        const raw = areaState.points.slice();
        areaState.isFreehandActive = false;

        const simplifiedLL = latlngsFromFreehand(raw);

        const totalLen = (() => {
          let sum = 0;
          for (let i = 1; i < raw.length; i++) sum += map.distance(raw[i-1], raw[i]);
          return sum;
        })();

        if (!simplifiedLL || simplifiedLL.length < 3 || totalLen < 20) {
          clearTempDrawing();
          areaState.isDrawing = false;
          setMarkersVisible(true);
          setAreaHintVisible(false, "");
          scheduleReload();
          return;
        }

        const ok = addAreaPolygon(simplifiedLL);
        clearTempDrawing();
        areaState.isDrawing = false;
        setMarkersVisible(true);
        setAreaHintVisible(false, "");
        scheduleReload();
      }

      function handleMapClickForAreas(e){
        if (!areaState.isDrawing) return false;

        if (areaState.mode === "points") {
          const ll = e.latlng;
          if (!ll) return true;

          if (areaState.points.length >= 3 && maybeCloseFirst(ll)) {
            finishDrawingPoints();
            return true;
          }

          addPointVertex(ll);
          return true;
        }

        return true;
      }

      map.on("mousedown", (e) => {
        if (areaState.isDrawing && areaState.mode === "freehand") {
          startFreehand(e);
        }
      });

      map.on("touchstart", (e) => {
        if (areaState.isDrawing && areaState.mode === "freehand") {
          startFreehand(e);
        }
      });

      async function loadPointsForCurrentView() {
        const b = getCurrentBounds();
        const z = map.getZoom();
        const f = getParams();

        if (areaState.isDrawing) {
          setStatus(areaState.lastHint || "Dibujando área...");
          return;
        }

        setStatus(`Cargando...`);
        const rows = await rpcSearchMapPoints(b, f);

        const filtered = rows.filter(isInsideAnyArea);

        clearMarkers();
        filtered.forEach(addPoint);

        setStatus(`Anuncios: ${filtered.length} | zoom ${z} | modo=${f.mode}`);
      }

      function scheduleReload() {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          try {
            await loadPointsForCurrentView();
          } catch (e) {
            const msg = (e && e.message) ? e.message : String(e);
            setStatus(`Error: ${msg}`);
            console.error(e);
          }
        }, 300);
      }

      async function geocodeCity(city) {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}&limit=1`;
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = await res.json();
        if (!data[0]) return null;
        return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
      }

      async function goToCity(city) {
        setStatus("Buscando ciudad...");
        const center = await geocodeCity(city);
        if (center) map.setView(center, 13);
        scheduleReload();
      }

      miniSearchForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const city = (miniQ.value || "").trim();
        if (!city) return;

        const u = new URL(window.location.href);
        u.searchParams.set("city", city);
        history.replaceState(null, "", u.toString());

        await goToCity(city);
      });

      document.getElementById("navFavoritos").addEventListener("click", (e) => {
        e.preventDefault();
        alert("MVP: Favoritos (requiere registro).");
      });

      document.getElementById("navLogin").addEventListener("click", (e) => {
        e.preventDefault();
        alert("MVP: Iniciar sesión.");
      });

      map.on("moveend", scheduleReload);
      map.on("zoomend", scheduleReload);

      map.on("click", (e) => {
        const consumed = handleMapClickForAreas(e);
        if (consumed) return;
        closeCard();
      });

      /* =========================
         CAPA SOL (SunCalc-like)
         ========================= */

      const ZOOM_SOL_MIN = 15;
      let sunEnabled = false;
      const sunState = { dateISO: null, minutes: null, sunriseMin: null, sunsetMin: null };

      function todayISO() {
        const d = new Date();
        const y = d.getFullYear();
        const m = String(d.getMonth()+1).padStart(2,"0");
        const day = String(d.getDate()).padStart(2,"0");
        return `${y}-${m}-${day}`;
      }

      function nowMinutes() {
        const d = new Date();
        return d.getHours()*60 + d.getMinutes();
      }

      function minutesToHHMM(mins) {
        const h = Math.floor(mins/60);
        const m = mins % 60;
        return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
      }

      function rad2deg(r){ return r * 180 / Math.PI; }

      function sunBearingAndAltDeg(lat, lng, dateObj){
        const pos = SunCalc.getPosition(dateObj, lat, lng);
        const azDeg = rad2deg(pos.azimuth);
        const bearingDeg = (180 + azDeg + 360) % 360;
        const altDeg = rad2deg(pos.altitude);
        return { bearingDeg, altDeg };
      }

      function bearingToCardinal(deg){
        const dirs = ["N","NE","E","SE","S","SO","O","NO"];
        const idx = Math.round(deg / 45) % 8;
        return dirs[idx];
      }

      function buildDateObj(iso, minutes) {
        const [y,m,d] = iso.split("-").map(x => parseInt(x,10));
        const hh = Math.floor(minutes/60);
        const mm = minutes % 60;
        return new Date(y, (m-1), d, hh, mm, 0, 0);
      }

      function svgClear(el){ while (el.firstChild) el.removeChild(el.firstChild); }
      function svgEl(name, attrs){
        const el = document.createElementNS("http://www.w3.org/2000/svg", name);
        if (attrs) for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
      }

      function polarXY(cx, cy, R, bearingDeg, altDeg){
        const altClamped = Math.max(-24, Math.min(90, altDeg));
        const r = ((90 - altClamped) / 90) * R;
        const t = bearingDeg * Math.PI / 180;
        const x = cx + r * Math.sin(t);
        const y = cy - r * Math.cos(t);
        return { x, y };
      }

      function arcPath(cx, cy, r, a0Deg, a1Deg){
        const a0 = (a0Deg - 90) * Math.PI/180;
        const a1 = (a1Deg - 90) * Math.PI/180;
        const x0 = cx + r * Math.cos(a0);
        const y0 = cy + r * Math.sin(a0);
        const x1 = cx + r * Math.cos(a1);
        const y1 = cy + r * Math.sin(a1);
        let da = ((a1Deg - a0Deg) % 360 + 360) % 360;
        const large = da > 180 ? 1 : 0;
        return `M ${x0.toFixed(2)} ${y0.toFixed(2)} A ${r.toFixed(2)} ${r.toFixed(2)} 0 ${large} 1 ${x1.toFixed(2)} ${y1.toFixed(2)}`;
      }

      function drawSunPolar(svg, centerLatLng, dateISO, minutes){
        const V = 1120;
        const cx = V/2;
        const cy = V/2;
        const R = 450;

        svg.setAttribute("viewBox", `0 0 ${V} ${V}`);
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        svgClear(svg);

        svg.appendChild(svgEl("circle", {
          cx, cy, r: R,
          fill: "rgba(255,255,255,0.00)",
          stroke: "rgba(0,0,0,0.35)",
          "stroke-width": "3"
        }));

        const axes = [
          { a:0,   label:"N", x: cx,         y: cy - R - 22, anchor:"middle" },
          { a:90,  label:"E", x: cx + R + 22, y: cy + 12,    anchor:"start"  },
          { a:180, label:"S", x: cx,         y: cy + R + 42, anchor:"middle" },
          { a:270, label:"O", x: cx - R - 22, y: cy + 12,    anchor:"end"    },
        ];

        [0,90,180,270].forEach(a=>{
          const p = polarXY(cx, cy, R, a, 0);
          svg.appendChild(svgEl("line", {
            x1: cx, y1: cy, x2: p.x, y2: p.y,
            stroke: "rgba(0,0,0,0.20)",
            "stroke-width": "2"
          }));
        });

        axes.forEach(o=>{
          const t = svgEl("text", {
            x: o.x,
            y: o.y,
            "text-anchor": o.anchor,
            "font-size": "34",
            fill: "rgba(0,0,0,0.45)"
          });
          t.textContent = o.label;
          svg.appendChild(t);
        });

        const dayNoon = buildDateObj(dateISO, 12*60);
        const times = SunCalc.getTimes(dayNoon, centerLatLng.lat, centerLatLng.lng);
        const sunrise = times.sunrise;
        const sunset = times.sunset;

        let haveSunTimes = false;

        if (sunrise instanceof Date && !isNaN(sunrise.getTime()) && sunset instanceof Date && !isNaN(sunset.getTime())) {
          const sr = sunBearingAndAltDeg(centerLatLng.lat, centerLatLng.lng, sunrise);
          const ss = sunBearingAndAltDeg(centerLatLng.lat, centerLatLng.lng, sunset);

          const sunriseBearing = sr.bearingDeg;
          const sunsetBearing = ss.bearingDeg;
          haveSunTimes = true;

          const d1 = arcPath(cx, cy, R, sunriseBearing, sunsetBearing);

          svg.appendChild(svgEl("path", {
            d: `${d1} L ${cx} ${cy} Z`,
            fill: "rgba(255, 196, 50, 0.14)",
            stroke: "none"
          }));

          svg.appendChild(svgEl("path", {
            d: d1,
            fill: "none",
            stroke: "rgba(255, 140, 0, 0.65)",
            "stroke-width": "6",
            "stroke-linecap": "round"
          }));

          const srPt = polarXY(cx, cy, R, sunriseBearing, 0);
          const ssPt = polarXY(cx, cy, R, sunsetBearing, 0);

          const riseSetStroke = "rgba(255, 140, 0, 0.85)";

          svg.appendChild(svgEl("line", {
            x1: cx, y1: cy, x2: srPt.x, y2: srPt.y,
            stroke: riseSetStroke,
            "stroke-width": "6",
            "stroke-linecap": "round"
          }));

          svg.appendChild(svgEl("line", {
            x1: cx, y1: cy, x2: ssPt.x, y2: ssPt.y,
            stroke: riseSetStroke,
            "stroke-width": "6",
            "stroke-linecap": "round"
          }));

          [srPt, ssPt].forEach(pt=>{
            svg.appendChild(svgEl("circle", {
              cx: pt.x, cy: pt.y, r: 12,
              fill: "rgba(0,0,0,0.22)"
            }));
          });
        }

        const curDate = buildDateObj(dateISO, minutes);
        const cur = sunBearingAndAltDeg(centerLatLng.lat, centerLatLng.lng, curDate);

        const meta = { isDay: cur.altDeg > 0, bearingDeg: cur.bearingDeg, altDeg: cur.altDeg };

        const sunR = Math.round(18 * 1.15);
        const sunStroke = Math.round(6 * 1.15);

        const sunRingYellow = "rgba(255, 196, 50, 0.98)";
        const sunLineYellow = "rgba(255, 196, 50, 0.86)";

        if (meta.isDay) {
          if (haveSunTimes) {
            const pts = [];
            const stepMin = 6;
            const start = sunrise.getTime();
            const end = sunset.getTime();
            for (let tt = start; tt <= end; tt += stepMin*60*1000) {
              const d = new Date(tt);
              const pa = sunBearingAndAltDeg(centerLatLng.lat, centerLatLng.lng, d);
              if (pa.altDeg >= 0) pts.push(polarXY(cx, cy, R, pa.bearingDeg, pa.altDeg));
            }
            if (pts.length >= 2) {
              const dAttr = pts.map((p,i)=> `${i===0?"M":"L"} ${p.x.toFixed(2)} ${p.y.toFixed(2)}`).join(" ");
              svg.appendChild(svgEl("path", {
                d: dAttr,
                fill: "none",
                stroke: "rgba(255, 140, 0, 0.88)",
                "stroke-width": "8",
                "stroke-linecap": "round",
                "stroke-linejoin": "round"
              }));
            }
          }

          const p = polarXY(cx, cy, R, cur.bearingDeg, cur.altDeg);

          svg.appendChild(svgEl("line", {
            x1: cx, y1: cy, x2: p.x, y2: p.y,
            stroke: sunLineYellow,
            "stroke-width": "8",
            "stroke-linecap": "round"
          }));

          svg.appendChild(svgEl("circle", {
            cx: p.x, cy: p.y, r: sunR,
            fill: "rgba(255, 120, 60, 0.95)",
            stroke: sunRingYellow,
            "stroke-width": String(sunStroke)
          }));
        } else {
          const p = polarXY(cx, cy, R, cur.bearingDeg, cur.altDeg);

          svg.appendChild(svgEl("circle", {
            cx: p.x, cy: p.y, r: sunR,
            fill: "rgba(165,165,165,0.86)",
            stroke: sunRingYellow,
            "stroke-width": String(sunStroke)
          }));
        }

        return meta;
      }

      function minutesOfDate(d){
        if (!(d instanceof Date) || isNaN(d.getTime())) return null;
        return d.getHours() * 60 + d.getMinutes();
      }

      function updateDaylightBand(){
        const c = map.getCenter();
        const iso = sunState.dateISO || todayISO();
        const noon = buildDateObj(iso, 12*60);
        const times = SunCalc.getTimes(noon, c.lat, c.lng);

        const sr = minutesOfDate(times.sunrise);
        const ss = minutesOfDate(times.sunset);

        sunState.sunriseMin = sr;
        sunState.sunsetMin = ss;

        const srPct = (sr == null) ? 0 : Math.max(0, Math.min(100, (sr / 1439) * 100));
        const ssPct = (ss == null) ? 0 : Math.max(0, Math.min(100, (ss / 1439) * 100));

        sunTrackEl.style.setProperty("--sr", `${srPct.toFixed(3)}%`);
        sunTrackEl.style.setProperty("--ss", `${ssPct.toFixed(3)}%`);
      }

      function updateSunOverlay(){
        const ok = sunEnabled && map.getZoom() >= ZOOM_SOL_MIN;

        sunOverlayEl.style.display = ok ? "block" : "none";
        sunTimebarEl.style.display = ok ? "block" : "none";
        sunDateDockEl.style.display = ok ? "block" : "none";

        if (!ok) return;

        const c = map.getCenter();
        const iso = sunState.dateISO || todayISO();
        const mins = (sunState.minutes != null) ? sunState.minutes : nowMinutes();

        updateDaylightBand();

        const meta = drawSunPolar(sunPolarOverlaySvg, c, iso, mins);

        if (meta.isDay) {
          const card = bearingToCardinal(meta.bearingDeg);
          sunOverlayLabelEl.textContent = `${minutesToHHMM(mins)} · ${card} · ${Math.round(meta.bearingDeg)}° · alt ${Math.round(meta.altDeg)}°`;
        } else {
          const card = bearingToCardinal(meta.bearingDeg);
          sunOverlayLabelEl.textContent = `${minutesToHHMM(mins)} · noche · ${card} · ${Math.round(meta.bearingDeg)}° · alt ${Math.round(meta.altDeg)}°`;
        }
      }

      function setSunEnabled(next){
        sunEnabled = next;
        updateSunOverlay();
      }

      function initHoursRow(){
        const frag = document.createDocumentFragment();
        for (let h = 0; h < 24; h++) {
          const s = document.createElement("span");
          s.textContent = String(h).padStart(2,"0");
          frag.appendChild(s);
        }
        sunHoursRowEl.innerHTML = "";
        sunHoursRowEl.appendChild(frag);
      }

      function preventMapDragOn(el){
        el.addEventListener("mousedown", (e) => e.stopPropagation());
        el.addEventListener("touchstart", (e) => e.stopPropagation(), { passive: true });
        el.addEventListener("wheel", (e) => e.stopPropagation(), { passive: true });
        el.addEventListener("click", (e) => e.stopPropagation());
      }

      initHoursRow();
      preventMapDragOn(sunTimebarEl);
      preventMapDragOn(sunDateDockEl);

      sunState.dateISO = todayISO();
      sunState.minutes = nowMinutes();

      sunDateEl.value = sunState.dateISO;
      sunRangeEl.value = String(sunState.minutes);

      sunRangeEl.addEventListener("input", () => {
        sunState.minutes = parseInt(sunRangeEl.value, 10);
        updateSunOverlay();
      });

      sunDateEl.addEventListener("change", () => {
        sunState.dateISO = sunDateEl.value || todayISO();
        updateSunOverlay();
      });

      sunNowBtn.addEventListener("click", () => {
        sunState.dateISO = todayISO();
        sunState.minutes = nowMinutes();
        sunDateEl.value = sunState.dateISO;
        sunRangeEl.value = String(sunState.minutes);
        updateSunOverlay();
      });

      const SunControl = L.Control.extend({
        options: { position: "topright" },
        onAdd: function() {
          const container = L.DomUtil.create("div", "quickCol");
          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          const btn = L.DomUtil.create("div", "qBtn", container);
          btn.id = "sunBtn";
          btn.title = "Sol";
          btn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="4"></circle>
              <path d="M12 2v2"></path><path d="M12 20v2"></path>
              <path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path>
              <path d="M2 12h2"></path><path d="M20 12h2"></path>
              <path d="M4.93 19.07l1.41-1.41"></path><path d="M17.66 6.34l1.41-1.41"></path>
            </svg>
          `;

          function setBtnEnabled() {
            const ok = map.getZoom() >= ZOOM_SOL_MIN;
            btn.classList.toggle("disabled", !ok);
            btn.title = ok ? "Sol" : `Acércate para activar (zoom ${ZOOM_SOL_MIN}+)`;
            if (!ok && sunEnabled) {
              btn.classList.remove("active");
              setSunEnabled(false);
            } else {
              updateSunOverlay();
            }
          }

          function forceOff(){
            if (sunEnabled) {
              sunEnabled = false;
              btn.classList.remove("active");
              updateSunOverlay();
            }
          }

          btn.addEventListener("click", () => {
            const ok = map.getZoom() >= ZOOM_SOL_MIN;
            if (!ok) return;

            if (areaState.mode) {
              setAreaMode(null);
            }

            const next = !sunEnabled;
            btn.classList.toggle("active", next);
            setSunEnabled(next);
          });

          map.on("zoomend", setBtnEnabled);
          setBtnEnabled();

          areaState.sunBtnEl = btn;
          areaState.sunBtnForceOff = forceOff;

          return container;
        }
      });

      map.addControl(new SunControl());

      map.on("moveend", () => { if (sunEnabled) updateSunOverlay(); });
      map.on("zoomend", () => { if (sunEnabled) updateSunOverlay(); });
      window.addEventListener("resize", () => { if (sunEnabled) updateSunOverlay(); });

      /* =========================
         FIN CAPA SOL
         ========================= */

      /* =========================
         CONTROLES AREAS
         ========================= */

    const AreasControl = L.Control.extend({
        options: { position: "topright" },
        onAdd: function() {
          const container = L.DomUtil.create("div", "quickRow");
          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          const btnPlus = L.DomUtil.create("div", "qBtnSmall", container);
          btnPlus.id = "areaPlusBtn";
          btnPlus.title = "Añadir otra área";
          btnPlus.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14"></path>
              <path d="M5 12h14"></path>
            </svg>
          `;

          const btnPoints = L.DomUtil.create("div", "qBtnSmall", container);
          btnPoints.id = "areaPointsBtn";
          btnPoints.title = "Dibujar área por puntos";
          btnPoints.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M5 6h6"></path>
              <path d="M5 12h10"></path>
              <path d="M5 18h14"></path>
              <circle cx="4" cy="6" r="1.2"></circle>
              <circle cx="4" cy="12" r="1.2"></circle>
              <circle cx="4" cy="18" r="1.2"></circle>
            </svg>
          `;

          const btnFree = L.DomUtil.create("div", "qBtnSmall", container);
          btnFree.id = "areaFreeBtn";
          btnFree.title = "Dibujar área libre";
          btnFree.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 16c2-6 6-9 10-9 3 0 5 2 6 5"></path>
              <path d="M4 16c2 3 5 5 9 5 3 0 6-1 7-3"></path>
              <path d="M7 6l2 2"></path>
            </svg>
          `;

          function clearAllAreas(){
            // borra polígonos existentes
            for (const a of areaState.polys.slice()) {
              if (a.poly) areasLayer.removeLayer(a.poly);
              if (a.delMarker) areasLayer.removeLayer(a.delMarker);
            }
            areaState.polys = [];
            // limpia dibujo temporal y estado
            cancelAreaDrawingOnly();
            deactivateAreasIfNone();
            scheduleReload();
          }

          function setBtnsDisabled(disabled){
            btnPoints.classList.toggle("disabled", disabled);
            btnFree.classList.toggle("disabled", disabled);
            btnPlus.classList.toggle("disabled", disabled);
            if (disabled) {
              btnPoints.title = "Límite alcanzado";
              btnFree.title = "Límite alcanzado";
              btnPlus.title = "Límite alcanzado";
            } else {
              btnPoints.title = "Dibujar área por puntos";
              btnFree.title = "Dibujar área libre";
              btnPlus.title = "Añadir otra área";
            }
          }

          function refresh(){
            const reached = areaState.polys.length >= MAX_AREAS;

            setBtnsDisabled(reached);

            // Visible si hay al menos 1 área y aún no llegamos al límite.
            // Da igual si estás en puntos o libre: está a la izquierda para ambos.
            btnPlus.style.display = (areaState.polys.length >= 1 && areaState.polys.length < MAX_AREAS) ? "grid" : "none";

            btnPoints.classList.toggle("active", areaState.mode === "points");
            btnFree.classList.toggle("active", areaState.mode === "freehand");
          }

          btnPoints.addEventListener("click", () => {
            if (areaState.polys.length >= MAX_AREAS) return;

            if (sunEnabled) {
              if (areaState.sunBtnForceOff) areaState.sunBtnForceOff();
            }

            if (areaState.mode === "points") {
              // deseleccionar = borrar áreas
              clearAllAreas();
              refresh();
              return;
            }

            setAreaMode("points");
            refresh();
          });

          btnFree.addEventListener("click", () => {
            if (areaState.polys.length >= MAX_AREAS) return;

            if (sunEnabled) {
              if (areaState.sunBtnForceOff) areaState.sunBtnForceOff();
            }

            if (areaState.mode === "freehand") {
              // deseleccionar = borrar áreas
              clearAllAreas();
              refresh();
              return;
            }

            setAreaMode("freehand");
            refresh();
          });

          btnPlus.addEventListener("click", () => {
            if (areaState.polys.length >= MAX_AREAS) return;
            if (!areaState.polys.length) return;

            if (sunEnabled) {
              if (areaState.sunBtnForceOff) areaState.sunBtnForceOff();
            }

            // “+” sirve en ambos modos: inicia otro dibujo con el modo activo.
            // Si no hay modo activo, no hacemos nada (porque no sabemos cuál usar).
            if (!areaState.mode) return;

            startNewAreaDrawing();
            refresh();
          });

          areaState.plusBtnEl = btnPlus;
          areaState.btnPointsEl = btnPoints;
          areaState.btnFreeEl = btnFree;

          refresh();
          return container;
        }
      });

      map.addControl(new AreasControl());

      function stopAreaInteractions(){
        cancelAreaDrawingOnly();
      }

      // Evitar que el “click” normal cierre la card mientras estamos dibujando, ya controlado arriba.
      // Aquí gestionamos el cierre por ESC para abortar dibujo (si quieres).
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (areaState.isDrawing) {
            stopAreaInteractions();
            updatePlusVisibility();
            scheduleReload();
          }
        }
      });

      // Si empiezas a dibujar, ocultamos anuncios; cuando terminas, vuelven (loadPointsForCurrentView hace el filtrado)
      // Implementación “B”: los modos no coexisten entre sí ni con Sol (ya forzamos apagado).
      // Al recargar: se borran (no persistimos nada).

      /* =========================
         ARRANQUE INICIAL
         ========================= */

      (async () => {
        try {
          if (initialParams.city) {
            miniQ.value = initialParams.city;
            await goToCity(initialParams.city);
          } else {
            await loadPointsForCurrentView();
          }
        } catch (e) {
          const msg = (e && e.message) ? e.message : String(e);
          setStatus(`Error al cargar datos: ${msg}`);
          alert("Error al cargar datos. Revisa Supabase.");
          console.error(e);
        }
      })();
    </script>
  </body>
</html>
